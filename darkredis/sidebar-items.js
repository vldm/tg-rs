initSidebarItems({"enum":[["Error","The `darkredis` error type."],["Value","Enum depicting the various possible responses one can get from Redis."]],"struct":[["Command","A struct for defining commands manually. If you want pipelining, use `CommandList`. # Example  ``` use darkredis::{Command, Connection}; # use darkredis::*; # #[tokio::main] # async fn main() { # let mut connection = Connection::connect(\"127.0.0.1:6379\", None).await.unwrap(); # connection.del(\"singular-key\").await.unwrap();"],["CommandList","A struct for defining commands manually, which allows for pipelining of several commands. If you need to only run one command, use `Command`, which has almost the same API. # Example  ``` use darkredis::{CommandList, Connection}; # use darkredis::*; # #[tokio::main] # async fn main() { # let mut connection = Connection::connect(\"127.0.0.1:6379\", None).await.unwrap(); # connection.del(\"pipelined-list\").await.unwrap();"],["Connection","A connection to Redis. Copying is cheap as the inner type is a simple, futures-aware, `Arc<Mutex>`, and will not create a new connection. Use a `ConnectionPool` if you want to use pooled conections. Every convenience function can work with any kind of data as long as it can be converted into bytes. Check the redis command reference for in-depth explanations of each command."],["ConnectionPool","A connection pool. Clones are cheap and is the expected way to send the pool around your application."],["Message","A message received from a channel."],["MessageStream","A stream of `Message`s. The stream will end if an error is encountered, if the logging feature is enabled. Requires a logger compatible with the `log` crate."],["PMessage","A message received from a channel (Pattern version)"],["PMessageStream","A stream of `PMessage`s. See `MessageStream` for more info."]],"type":[["Result","Result type used in the whole crate."]]});